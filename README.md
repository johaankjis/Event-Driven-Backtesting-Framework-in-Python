# Event-Driven Backtesting Framework in Python

A professional-grade, event-driven backtesting framework for algorithmic trading strategies. Built with Python's asyncio for high-performance event processing and realistic market simulation.

## 🚀 Features

- **Event-Driven Architecture**: Asynchronous event processing using Python's asyncio for scalable, production-like backtesting
- **Realistic Market Simulation**: 
  - Configurable slippage and latency modeling
  - Commission calculations
  - Execution delays with 95% fill accuracy
- **Modular Design**: Plug-and-play components for easy customization
- **Comprehensive Metrics**: 
  - Sharpe & Sortino ratios
  - Maximum drawdown analysis
  - Hit rate calculations
  - Volatility metrics
- **Rich Visualizations**: 
  - Equity curves
  - Drawdown charts
  - Rolling performance metrics
  - Returns distribution analysis
- **Strategy Examples**: Pre-built mean reversion strategy demonstrating the framework

## 📋 Table of Contents

- [Architecture](#architecture)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Components](#components)
- [Usage Examples](#usage-examples)
- [Performance Metrics](#performance-metrics)
- [Project Structure](#project-structure)
- [Requirements](#requirements)
- [Contributing](#contributing)

## 🏗️ Architecture

The framework follows a clean, event-driven architecture with clear separation of concerns:

```
┌─────────────────┐
│  Data Handler   │ ──> Market Events
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  Event Engine   │ ◄──> Event Queue (FIFO)
└─────────────────┘
         │
    ┌────┴─────┬──────────┬──────────┐
    ▼          ▼          ▼          ▼
┌────────┐ ┌────────┐ ┌──────────┐ ┌──────────┐
│Strategy│ │Portfolio│ │Execution│ │ Metrics  │
└────────┘ └────────┘ └──────────┘ └──────────┘
    │          │          │
    ▼          ▼          ▼
 Signal     Order       Fill
 Events     Events     Events
```

### Event Flow:
1. **Market Events** → Generated by Data Handler from historical data
2. **Signal Events** → Generated by Strategy based on market data
3. **Order Events** → Generated by Portfolio based on signals
4. **Fill Events** → Generated by Execution Handler after order execution

## 🔧 Installation

### Prerequisites
- Python 3.8 or higher
- pip package manager

### Install Dependencies

```bash
# Clone the repository
git clone https://github.com/johaankjis/Event-Driven-Backtesting-Framework-in-Python.git
cd Event-Driven-Backtesting-Framework-in-Python

# Install required packages
pip install -r requirements.txt
```

## 🚦 Quick Start

Run the example mean reversion strategy:

```bash
# Run the complete backtest with visualizations
python scripts/run_backtest.py
```

This will:
1. Load synthetic market data for AAPL
2. Execute a mean reversion strategy
3. Generate performance metrics
4. Create visualization charts in the `results/` directory

### Expected Output:

```
...
============================================================
BACKTEST RESULTS
============================================================

Initial Capital: $100,000.00
Final Equity: $105,234.56
Total Return: 5.23%

Sharpe Ratio: 1.45
Sortino Ratio: 2.13
Max Drawdown: 3.21%
Volatility (annualized): 12.45%

Total Trades: 24
Average Return per Trade: 0.0245%
Hit Rate: 58.33%
```

## 🧩 Components

### 1. Event Engine (`core/event_engine.py`)
Central event dispatcher managing events in FIFO order using asyncio.

**Key Features:**
- Asynchronous event processing
- Type-based handler registration
- Non-blocking event loop

### 2. Data Handler (`core/data_handler.py`)
Streams historical market data as MarketEvents with support for multiple symbols.

**Key Features:**
- Asynchronous data loading
- Synthetic data generation for testing
- Bar-by-bar streaming

**Methods:**
- `load_data()`: Load historical data
- `stream_next_bar()`: Stream next data point
- `get_latest_bars()`: Retrieve recent bars for analysis

### 3. Strategy (`core/strategy.py`)
Base class for implementing trading strategies.

**Built-in Strategies:**
- **Mean Reversion Strategy**: Uses Bollinger Bands to identify oversold/overbought conditions

**Custom Strategy Development:**
```python
class CustomStrategy(Strategy):
    def calculate_signals(self, event: MarketEvent):
        # Your strategy logic here
        # Generate SignalEvents based on market data
        pass
```

### 4. Portfolio (`core/portfolio.py`)
Manages positions, tracks P&L, and generates orders from signals.

**Key Features:**
- Position tracking
- Dynamic capital allocation
- Equity curve generation
- Trade logging

### 5. Execution Handler (`core/execution.py`)
Simulates realistic order execution with slippage and latency.

**Key Features:**
- Configurable slippage (default: 0.1%)
- Execution latency simulation (10-50ms)
- Commission calculations
- Market and limit order support

### 6. Performance Metrics (`core/metrics.py`)
Comprehensive performance analysis toolkit.

**Available Metrics:**
- **Sharpe Ratio**: Risk-adjusted return metric
- **Sortino Ratio**: Downside risk-adjusted return
- **Maximum Drawdown**: Largest peak-to-trough decline
- **Hit Rate**: Percentage of profitable trades
- **Volatility**: Annualized return volatility

## 📊 Usage Examples

### Example 1: Basic Backtest

```python
import asyncio
from datetime import datetime
from core.event_engine import EventEngine
from core.data_handler import DataHandler
from core.strategy import MeanReversionStrategy
from core.portfolio import Portfolio
from core.execution import ExecutionHandler

async def run_simple_backtest():
    # Initialize components
    event_engine = EventEngine()
    data_handler = DataHandler(event_engine, symbols=['AAPL'])
    portfolio = Portfolio(event_engine, initial_capital=100000.0)
    execution = ExecutionHandler(event_engine)
    strategy = MeanReversionStrategy(event_engine, data_handler, 'AAPL')
    
    # Register event handlers
    event_engine.register_handler(EventType.MARKET, 
                                  lambda e: strategy.calculate_signals(e))
    
    # Load data and run
    await data_handler.load_data(
        start_date=datetime(2023, 1, 1),
        end_date=datetime(2024, 1, 1)
    )
    
    while await data_handler.stream_next_bar():
        await event_engine.process_events()
    
    return portfolio

portfolio = asyncio.run(run_simple_backtest())
```

### Example 2: Custom Strategy Implementation

```python
from core.strategy import Strategy
from core.event import SignalEvent, SignalType

class MovingAverageCrossover(Strategy):
    def __init__(self, event_engine, data_handler, symbol, 
                 short_window=10, long_window=30):
        super().__init__(event_engine, data_handler)
        self.symbol = symbol
        self.short_window = short_window
        self.long_window = long_window
        
    def calculate_signals(self, event: MarketEvent):
        bars = self.data_handler.get_latest_bars(
            self.symbol, self.long_window
        )
        
        if bars is None or len(bars) < self.long_window:
            return
        
        short_ma = bars['close'][-self.short_window:].mean()
        long_ma = bars['close'].mean()
        
        # Golden cross
        if short_ma > long_ma:
            signal = SignalEvent(
                timestamp=event.timestamp,
                symbol=self.symbol,
                signal_type=SignalType.LONG,
                strength=1.0
            )
            self.event_engine.put_event(signal)
```

### Example 3: Custom Metrics Calculation

```python
from core.metrics import PerformanceMetrics

# Calculate Sharpe ratio
returns = portfolio.get_returns()
sharpe = PerformanceMetrics.sharpe_ratio(returns, periods_per_year=252)

# Calculate maximum drawdown
equity_curve = pd.Series([eq for _, eq in portfolio.equity_curve])
max_dd, start, end = PerformanceMetrics.max_drawdown(equity_curve)

print(f"Sharpe Ratio: {sharpe:.2f}")
print(f"Max Drawdown: {max_dd*100:.2f}% from {start} to {end}")
```

## 📈 Performance Metrics

The framework calculates comprehensive performance metrics:

| Metric | Description | Formula |
|--------|-------------|---------|
| **Total Return** | Overall portfolio return | `(Final - Initial) / Initial * 100` |
| **Sharpe Ratio** | Risk-adjusted return | `√(periods) * mean(returns) / std(returns)` |
| **Sortino Ratio** | Downside risk-adjusted return | `√(periods) * mean(returns) / std(negative_returns)` |
| **Max Drawdown** | Largest peak-to-trough decline | `max((Peak - Trough) / Peak)` |
| **Volatility** | Annualized return volatility | `std(returns) * √(periods)` |
| **Hit Rate** | Percentage of profitable trades | `profitable_trades / total_trades` |

## 📁 Project Structure

```
Event-Driven-Backtesting-Framework-in-Python/
│
├── core/                          # Core framework components
│   ├── event.py                   # Event definitions and types
│   ├── event_engine.py            # Async event dispatcher
│   ├── data_handler.py            # Market data streaming
│   ├── strategy.py                # Strategy base class
│   ├── portfolio.py               # Portfolio management
│   ├── execution.py               # Order execution simulation
│   └── metrics.py                 # Performance calculations
│
├── examples/                      # Example strategies
│   └── mean_reversion_demo.py     # Mean reversion example
│
├── scripts/                       # Utility scripts
│   └── run_backtest.py            # Main backtest runner
│
├── visualization/                 # Plotting and dashboards
│   ├── plots.py                   # Individual plot functions
│   └── dashboard.py               # Comprehensive dashboard
│
├── requirements.txt               # Python dependencies
├── package.json                   # Node.js dependencies (optional)
└── README.md                      # This file
```

## 📦 Requirements

### Python Dependencies

```
pandas>=2.0.0
numpy>=1.24.0
matplotlib>=3.7.0
seaborn>=0.12.0
```

Install all dependencies:
```bash
pip install -r requirements.txt
```

## 🎯 Key Advantages

1. **Production-Ready Architecture**: Event-driven design mirrors real trading systems
2. **Realistic Simulations**: Accounts for slippage, latency, and commissions
3. **High Performance**: Async I/O for efficient data processing
4. **Extensible**: Easy to add new strategies, data sources, and metrics
5. **Well-Documented**: Clear code structure with comprehensive docstrings
6. **Visualization Tools**: Built-in plotting for analysis and reporting

## 🔍 Advanced Features

### Asynchronous Processing
The framework leverages Python's asyncio for non-blocking event processing:

```python
async def process_events(self):
    while self.event_queue:
        event = self.event_queue.popleft()
        handlers = self.handlers.get(event.event_type, [])
        
        for handler in handlers:
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                handler(event)
```

### Realistic Execution Modeling
Execution includes multiple layers of realism:
- **Latency**: 10-50ms random delay
- **Slippage**: Market impact based on order type
- **Commission**: Configurable transaction costs

## 🤝 Contributing

Contributions are welcome! Here's how you can help:

1. **Fork the repository**
2. **Create a feature branch**: `git checkout -b feature/your-feature`
3. **Commit your changes**: `git commit -m 'Add some feature'`
4. **Push to the branch**: `git push origin feature/your-feature`
5. **Open a Pull Request**

### Development Guidelines

- Follow PEP 8 style guidelines
- Add docstrings to all classes and methods
- Include type hints where appropriate
- Write unit tests for new features
- Update documentation as needed

## 📝 License

This project is open source and available for educational and research purposes.

## 🙏 Acknowledgments

Built with modern Python best practices and inspired by production trading systems.

## 📧 Contact

For questions, issues, or suggestions, please open an issue on GitHub.

---

**Happy Backtesting! 📈**

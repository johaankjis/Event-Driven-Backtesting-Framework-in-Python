# Event-Driven Backtesting Framework in Python

A professional-grade, event-driven backtesting framework for algorithmic trading strategies. Built with Python's asyncio for high-performance event processing and realistic market simulation.

## ğŸš€ Features

- **Event-Driven Architecture**: Asynchronous event processing using Python's asyncio for scalable, production-like backtesting
- **Realistic Market Simulation**: 
  - Configurable slippage and latency modeling
  - Commission calculations
  - Execution delays with 95% fill accuracy
- **Modular Design**: Plug-and-play components for easy customization
- **Comprehensive Metrics**: 
  - Sharpe & Sortino ratios
  - Maximum drawdown analysis
  - Hit rate calculations
  - Volatility metrics
- **Rich Visualizations**: 
  - Equity curves
  - Drawdown charts
  - Rolling performance metrics
  - Returns distribution analysis
- **Strategy Examples**: Pre-built mean reversion strategy demonstrating the framework

## ğŸ“‹ Table of Contents

- [Architecture](#architecture)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Components](#components)
- [Usage Examples](#usage-examples)
- [Performance Metrics](#performance-metrics)
- [Project Structure](#project-structure)
- [Requirements](#requirements)
- [Contributing](#contributing)

## ğŸ—ï¸ Architecture

The framework follows a clean, event-driven architecture with clear separation of concerns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Data Handler   â”‚ â”€â”€> Market Events
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Event Engine   â”‚ â—„â”€â”€> Event Queue (FIFO)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼          â–¼          â–¼          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Strategyâ”‚ â”‚Portfolioâ”‚ â”‚Executionâ”‚ â”‚ Metrics  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚          â”‚          â”‚
    â–¼          â–¼          â–¼
 Signal     Order       Fill
 Events     Events     Events
```

### Event Flow:
1. **Market Events** â†’ Generated by Data Handler from historical data
2. **Signal Events** â†’ Generated by Strategy based on market data
3. **Order Events** â†’ Generated by Portfolio based on signals
4. **Fill Events** â†’ Generated by Execution Handler after order execution

## ğŸ”§ Installation

### Prerequisites
- Python 3.8 or higher
- pip package manager

### Install Dependencies

```bash
# Clone the repository
git clone https://github.com/johaankjis/Event-Driven-Backtesting-Framework-in-Python.git
cd Event-Driven-Backtesting-Framework-in-Python

# Install required packages
pip install -r requirements.txt
```

## ğŸš¦ Quick Start

Run the example mean reversion strategy:

```bash
# Run the complete backtest with visualizations
python scripts/run_backtest.py
```

This will:
1. Load synthetic market data for AAPL
2. Execute a mean reversion strategy
3. Generate performance metrics
4. Create visualization charts in the `results/` directory

### Expected Output:

```
...
============================================================
BACKTEST RESULTS
============================================================

Initial Capital: $100,000.00
Final Equity: $105,234.56
Total Return: 5.23%

Sharpe Ratio: 1.45
Sortino Ratio: 2.13
Max Drawdown: 3.21%
Volatility (annualized): 12.45%

Total Trades: 24
Average Return per Trade: 0.0245%
Hit Rate: 58.33%
```

## ğŸ§© Components

### 1. Event Engine (`core/event_engine.py`)
Central event dispatcher managing events in FIFO order using asyncio.

**Key Features:**
- Asynchronous event processing
- Type-based handler registration
- Non-blocking event loop

### 2. Data Handler (`core/data_handler.py`)
Streams historical market data as MarketEvents with support for multiple symbols.

**Key Features:**
- Asynchronous data loading
- Synthetic data generation for testing
- Bar-by-bar streaming

**Methods:**
- `load_data()`: Load historical data
- `stream_next_bar()`: Stream next data point
- `get_latest_bars()`: Retrieve recent bars for analysis

### 3. Strategy (`core/strategy.py`)
Base class for implementing trading strategies.

**Built-in Strategies:**
- **Mean Reversion Strategy**: Uses Bollinger Bands to identify oversold/overbought conditions

**Custom Strategy Development:**
```python
class CustomStrategy(Strategy):
    def calculate_signals(self, event: MarketEvent):
        # Your strategy logic here
        # Generate SignalEvents based on market data
        pass
```

### 4. Portfolio (`core/portfolio.py`)
Manages positions, tracks P&L, and generates orders from signals.

**Key Features:**
- Position tracking
- Dynamic capital allocation
- Equity curve generation
- Trade logging

### 5. Execution Handler (`core/execution.py`)
Simulates realistic order execution with slippage and latency.

**Key Features:**
- Configurable slippage (default: 0.1%)
- Execution latency simulation (10-50ms)
- Commission calculations
- Market and limit order support

### 6. Performance Metrics (`core/metrics.py`)
Comprehensive performance analysis toolkit.

**Available Metrics:**
- **Sharpe Ratio**: Risk-adjusted return metric
- **Sortino Ratio**: Downside risk-adjusted return
- **Maximum Drawdown**: Largest peak-to-trough decline
- **Hit Rate**: Percentage of profitable trades
- **Volatility**: Annualized return volatility

## ğŸ“Š Usage Examples

### Example 1: Basic Backtest

```python
import asyncio
from datetime import datetime
from core.event_engine import EventEngine
from core.data_handler import DataHandler
from core.strategy import MeanReversionStrategy
from core.portfolio import Portfolio
from core.execution import ExecutionHandler

async def run_simple_backtest():
    # Initialize components
    event_engine = EventEngine()
    data_handler = DataHandler(event_engine, symbols=['AAPL'])
    portfolio = Portfolio(event_engine, initial_capital=100000.0)
    execution = ExecutionHandler(event_engine)
    strategy = MeanReversionStrategy(event_engine, data_handler, 'AAPL')
    
    # Register event handlers
    event_engine.register_handler(EventType.MARKET, 
                                  lambda e: strategy.calculate_signals(e))
    
    # Load data and run
    await data_handler.load_data(
        start_date=datetime(2023, 1, 1),
        end_date=datetime(2024, 1, 1)
    )
    
    while await data_handler.stream_next_bar():
        await event_engine.process_events()
    
    return portfolio

portfolio = asyncio.run(run_simple_backtest())
```

### Example 2: Custom Strategy Implementation

```python
from core.strategy import Strategy
from core.event import SignalEvent, SignalType

class MovingAverageCrossover(Strategy):
    def __init__(self, event_engine, data_handler, symbol, 
                 short_window=10, long_window=30):
        super().__init__(event_engine, data_handler)
        self.symbol = symbol
        self.short_window = short_window
        self.long_window = long_window
        
    def calculate_signals(self, event: MarketEvent):
        bars = self.data_handler.get_latest_bars(
            self.symbol, self.long_window
        )
        
        if bars is None or len(bars) < self.long_window:
            return
        
        short_ma = bars['close'][-self.short_window:].mean()
        long_ma = bars['close'].mean()
        
        # Golden cross
        if short_ma > long_ma:
            signal = SignalEvent(
                timestamp=event.timestamp,
                symbol=self.symbol,
                signal_type=SignalType.LONG,
                strength=1.0
            )
            self.event_engine.put_event(signal)
```

### Example 3: Custom Metrics Calculation

```python
from core.metrics import PerformanceMetrics

# Calculate Sharpe ratio
returns = portfolio.get_returns()
sharpe = PerformanceMetrics.sharpe_ratio(returns, periods_per_year=252)

# Calculate maximum drawdown
equity_curve = pd.Series([eq for _, eq in portfolio.equity_curve])
max_dd, start, end = PerformanceMetrics.max_drawdown(equity_curve)

print(f"Sharpe Ratio: {sharpe:.2f}")
print(f"Max Drawdown: {max_dd*100:.2f}% from {start} to {end}")
```

## ğŸ“ˆ Performance Metrics

The framework calculates comprehensive performance metrics:

| Metric | Description | Formula |
|--------|-------------|---------|
| **Total Return** | Overall portfolio return | `(Final - Initial) / Initial * 100` |
| **Sharpe Ratio** | Risk-adjusted return | `âˆš(periods) * mean(returns) / std(returns)` |
| **Sortino Ratio** | Downside risk-adjusted return | `âˆš(periods) * mean(returns) / std(negative_returns)` |
| **Max Drawdown** | Largest peak-to-trough decline | `max((Peak - Trough) / Peak)` |
| **Volatility** | Annualized return volatility | `std(returns) * âˆš(periods)` |
| **Hit Rate** | Percentage of profitable trades | `profitable_trades / total_trades` |

## ğŸ“ Project Structure

```
Event-Driven-Backtesting-Framework-in-Python/
â”‚
â”œâ”€â”€ core/                          # Core framework components
â”‚   â”œâ”€â”€ event.py                   # Event definitions and types
â”‚   â”œâ”€â”€ event_engine.py            # Async event dispatcher
â”‚   â”œâ”€â”€ data_handler.py            # Market data streaming
â”‚   â”œâ”€â”€ strategy.py                # Strategy base class
â”‚   â”œâ”€â”€ portfolio.py               # Portfolio management
â”‚   â”œâ”€â”€ execution.py               # Order execution simulation
â”‚   â””â”€â”€ metrics.py                 # Performance calculations
â”‚
â”œâ”€â”€ examples/                      # Example strategies
â”‚   â””â”€â”€ mean_reversion_demo.py     # Mean reversion example
â”‚
â”œâ”€â”€ scripts/                       # Utility scripts
â”‚   â””â”€â”€ run_backtest.py            # Main backtest runner
â”‚
â”œâ”€â”€ visualization/                 # Plotting and dashboards
â”‚   â”œâ”€â”€ plots.py                   # Individual plot functions
â”‚   â””â”€â”€ dashboard.py               # Comprehensive dashboard
â”‚
â”œâ”€â”€ requirements.txt               # Python dependencies
â”œâ”€â”€ package.json                   # Node.js dependencies (optional)
â””â”€â”€ README.md                      # This file
```

## ğŸ“¦ Requirements

### Python Dependencies

```
pandas>=2.0.0
numpy>=1.24.0
matplotlib>=3.7.0
seaborn>=0.12.0
```

Install all dependencies:
```bash
pip install -r requirements.txt
```

## ğŸ¯ Key Advantages

1. **Production-Ready Architecture**: Event-driven design mirrors real trading systems
2. **Realistic Simulations**: Accounts for slippage, latency, and commissions
3. **High Performance**: Async I/O for efficient data processing
4. **Extensible**: Easy to add new strategies, data sources, and metrics
5. **Well-Documented**: Clear code structure with comprehensive docstrings
6. **Visualization Tools**: Built-in plotting for analysis and reporting

## ğŸ” Advanced Features

### Asynchronous Processing
The framework leverages Python's asyncio for non-blocking event processing:

```python
async def process_events(self):
    while self.event_queue:
        event = self.event_queue.popleft()
        handlers = self.handlers.get(event.event_type, [])
        
        for handler in handlers:
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                handler(event)
```

### Realistic Execution Modeling
Execution includes multiple layers of realism:
- **Latency**: 10-50ms random delay
- **Slippage**: Market impact based on order type
- **Commission**: Configurable transaction costs

## ğŸ¤ Contributing

Contributions are welcome! Here's how you can help:

1. **Fork the repository**
2. **Create a feature branch**: `git checkout -b feature/your-feature`
3. **Commit your changes**: `git commit -m 'Add some feature'`
4. **Push to the branch**: `git push origin feature/your-feature`
5. **Open a Pull Request**

### Development Guidelines

- Follow PEP 8 style guidelines
- Add docstrings to all classes and methods
- Include type hints where appropriate
- Write unit tests for new features
- Update documentation as needed

## ğŸ“ License

This project is open source and available for educational and research purposes.

## ğŸ™ Acknowledgments

Built with modern Python best practices and inspired by production trading systems.

## ğŸ“§ Contact

For questions, issues, or suggestions, please open an issue on GitHub.

---

**Happy Backtesting! ğŸ“ˆ**
